<!DOCTYPE html>
<html>
<head>
    <title>Makigame 2.0</title>
    <style>
        table{border: 2px solid; margin: 15px}
        body{font-family: Arial}
        td{padding: 6px}
    </style>
</head>

<body>
    <div align="center">
        <h1>MAKIGAME 2.0</h1>
        <canvas id="canid" width="1000" height="577" style="border:3px solid black;">
        </canvas>

        <table border="1" cellspacing="2">
            <tr>
                <td>Movement: Arrow Keys</td>
                <td>Restart: R</td>
                <td>Pause: P</td>
            </tr>
        </table>
    </div>

<script>
/* todo: 3d object transitions+animation
 * collectables for score: score?!
 * (collect 1 -> shoot cooldown "time remaining:"+visual bar under player, shoot for score (bigger turn into smaller), no shoot = overwhealmed - needs balancing; collect more -> stacking for epicness)
 * player2?: colliding/blocking?, mouse controls? (menu only imo) */

// GLOBALS, START
var canvas = document.getElementById("canid"),
    W = canvas.width,
    H = canvas.height,
    HeaderH = 27,
    
    // keyboard key codes:
    UP = 38,
    DOWN = 40,
    LEFT = 37,
    RIGHT = 39,
    
    P = 80,
    R = 82,
    
    Keys = {};
addEventListener("keydown",
                 function(e){Keys[e.keyCode] = true}
                 ,false);
addEventListener("keyup",
                 function(e){Keys[e.keyCode] = false}
                 ,false);              

var Drawing = canvas.getContext("2d"),

    Objects = new objectManager(),
    Spawner = new spawner(),
    Game = new gameStuff();
	
Game.start();

// GAME CLASS
function gameStuff(){
    var startTime = then = Date.now(),  // 'then' used for deltatime
        interval,                       // for storing main loop interval
        spawnFlag = false,              // for enemy spawn permission
        turnFlag = false,               // for enemy turning permission
        collisionCounter = 0,           // counts player collisions, lives = 10 - collisions
        spawnCounter = 0,               // counts spawned enemies
        endFlag = false,                // game over flag
        
        // for background draw changes
        collisionCounterOld = collisionCounter,
        spawnCounterOld = spawnCounter,
        secondsOld = 0,
        
        // flags for game pause
        paused = [false, true];
        
    Drawing.font = "17px Arial";
    
    var restart = function(){
        // reset timers, counters and flags
        startTime = then = Date.now();
        collisionCounter = spawnCounter = 0;
        spawnFlag = false,
        turnFlag = false,
        endFlag = false,
        paused = [false, true];
        
        // reset objects
        Objects = new objectManager();
        collisionCounter += Objects.checkCollisions();
        drawBG(false);
        Objects.drawAll();
    }
    // premission for spawning enemies
    var canSpawn = function(){
        if (spawnCounter >= 90) return false;

        //deciseconds
        var dseconds = Math.floor( (Date.now()-startTime) / 100 ),
            spawnInterval = 25;

        // returns true every time the interval passes
        // 'spawnflag' used to limit 1 spawn in the decisecond
        if (dseconds%spawnInterval===0 && dseconds>0)
                if( !spawnFlag ){
                        spawnFlag = true;
                        return true;
                }else return false;
        else{
                spawnFlag = false;
                return false;
        }
    }
    // returns miliseconds passed since last call
    var getDeltaTime = function(){
        var now = Date.now(),
            delta = now - then;
        then = now;
        return delta;
    }
    // handles pause - unpaused transitions, paused
    var handlePause = function(){
        if (!Keys[P]) paused[1] = true;
        if (Keys[P] && paused[1]){
            paused[0] = !paused[0];
            paused[1] = false;
            // pause: draw PAUSED sign
            if (paused[0]){
                var tempFS = Drawing.fillStyle,
                    tempSS = Drawing.strokeStyle,
                    tempF = Drawing.font,
                    tempTA = Drawing.textAlign,

                    w = 110, h = 40; // rect width/height

                Drawing.fillStyle = "#CC6633";
                Drawing.fillRect(W/2 - w/2, H/2 + HeaderH - h/2, w, h);
                Drawing.strokeStyle = "black";
                Drawing.beginPath();
                Drawing.rect(W/2 - w/2, H/2 + HeaderH - h/2, w, h);
                Drawing.closePath();
                Drawing.stroke();

                Drawing.fillStyle = "black";
                Drawing.font = "20px Arial";
                Drawing.textAlign = "center";
                Drawing.fillText("PAUSED",
                                W/2, H/2 + HeaderH + 7);

                Drawing.fillStyle = tempFS;
                Drawing.strokeStyle = tempSS;
                Drawing.font = tempF;
                Drawing.textAlign = tempTA;
            }
            /* unpause:
             * adds pause time to starttime for calulations
             * deltatime resets */
            if (!paused[0]) startTime += getDeltaTime();
        }
        // returns true if the game is paused, false if not
        if (paused[0]) return true;
        else return false;
    }
    var gameOver = function(){
        // draws GAME OVER sign
        var tempFS = Drawing.fillStyle,
            tempSS = Drawing.strokeStyle,
            tempF = Drawing.font,
            tempTA = Drawing.textAlign,

            w = 140, h = 40; // rect width/height
        
        Drawing.fillStyle = "#CC6633";
        Drawing.fillRect(W/2 - w/2, H/2 + HeaderH - h/2, w, h);
        Drawing.strokeStyle = "black";
        Drawing.beginPath();
        Drawing.rect(W/2 - w/2, H/2 + HeaderH - h/2, w, h);
        Drawing.closePath();
        Drawing.stroke();

        Drawing.fillStyle = "black";
        Drawing.font = "20px Arial";
        Drawing.textAlign = "center";
        Drawing.fillText("GAME OVER",
                        W/2, H/2 + HeaderH + 7);

        Drawing.fillStyle = tempFS;
        Drawing.strokeStyle = tempSS;
        Drawing.font = tempF;
        Drawing.textAlign = tempTA;
        
        endFlag = true;
    }
    var drawBG = function(isFirst){
        // first time running function
        if (isFirst){
            // background for header
            Drawing.fillStyle = "#CC6633";
            Drawing.fillRect(0, 0, W, 25);
            // black line
            Drawing.fillStyle = "black";
            Drawing.fillRect(0, 25, W, 2);
            
            // lives remaining and enemies spawned counter display
            Drawing.textAlign = "left";
            Drawing.fillText("Lives: " +
                    ( collisionCounter>0 ? "0"+(10-collisionCounter) : 10-collisionCounter ) +
                    "     Enemies: " + spawnCounter, 4, 18);
            
            // time elapsed display
            var time = Date.now() - startTime,
                    minutes = Math.floor( (time/1000) / 60 ),
                    seconds = Math.floor( (time/1000) ) % 60;
            Drawing.textAlign = "right";
            Drawing.fillText("Time elapsed: " +
                    ( minutes<10 ? "0"+minutes : minutes ) + ":" + ( seconds<10 ? "0"+seconds : seconds ),
                    W-4, 18);		
        }
        // draws if collision counter changed
        if ( collisionCounter !== collisionCounterOld ){
            collisionCounterOld = collisionCounter;

            Drawing.fillStyle = "#CC6633";
            Drawing.fillRect(51, 6, 21, 12);

            Drawing.fillStyle = "black";
            Drawing.textAlign = "left";
            Drawing.fillText( (collisionCounter>0 ? "0"+(10-collisionCounter) : 10-collisionCounter),
                    51, 18);
        }
        // draws if spawn counter changed
        if ( spawnCounter !== spawnCounterOld ){
            spawnCounterOld = spawnCounter;

            Drawing.fillStyle = "#CC6633";
            Drawing.fillRect(167, 6, 29, 12);

            Drawing.fillStyle = "black";
            Drawing.textAlign = "left";
            Drawing.fillText(spawnCounter, 167, 18);
        }
        
        var time = Date.now() - startTime,
                minutes = Math.floor( (time/1000) / 60 ),
                seconds = Math.floor( time/1000 ) % 60;
        if (minutes >= 60) minutes = seconds = 59;
        // draws if a second passed
        if ( seconds !== secondsOld ){
            secondsOld = seconds;
                    
            Drawing.fillStyle = "#CC6633";
            Drawing.fillRect(W-46, 6, 42, 12);

            Drawing.fillStyle = "black";
            Drawing.textAlign = "right";
            Drawing.fillText( ( minutes<10 ? "0"+minutes : minutes ) + ":" + ( seconds<10 ? "0"+seconds : seconds ),
                    W-4, 18);
        }
	
        // main game background
        Drawing.fillStyle = "#FFCC99";
        Drawing.fillRect(0, 27, W, H-22);
    }
        
    this.mainLoop = function(){
        // game restart condition
        if (Keys[R]) restart();
        // game end condition
        if ( collisionCounter>=10 && !endFlag ) gameOver();
        if ( endFlag ) return;
        // game pause condition
        /* Keys[P]: P is pressed
         * paused[0]: game is paused
         * !paused[1]: waiting for P to be released */
        if (Keys[P] || paused[0] || !paused[1])
            var isPaused = handlePause();
        if (isPaused) return;

        Objects.moveAll(getDeltaTime());
        if ( canSpawn() ) Spawner.spawnRandom(3);
        collisionCounter += Objects.checkCollisions();

        drawBG(false);
        Objects.drawAll();
    }
    this.start = function(){
        collisionCounter += Objects.checkCollisions();
        drawBG(true);
        Objects.drawAll();
        
        var temp = this;
        interval = setInterval( function(){ return temp.mainLoop() }, 1);
    }
    this.canTurn = function(){
        var seconds = Math.floor( (Date.now()-startTime) / 1000 );
    
        if (seconds%15===0 && seconds>20){
            if ( !turnFlag ){
                turnFlag = true;
                return true;
            }else return false;
        }else{
            turnFlag = false;
            return false;
        }
    }
    this.spawned = function(num){ spawnCounter += num }
    this.despawned = function(num){ spawnCounter -= num }
}

// SPAWNER CLASS
function spawner(){
    var spawnSquareOrCircle = function(isSquare, isCircle){
        var x, y,   // coords
            w, h,   // width/height
            color,
            v,      // speed
            angle;  // moving angle
	
        // managing spawn chance for each enemy type
        switch ( Math.floor(Math.random()*6) ){
            case 0:
                    w = h = 35;
                    color = "blue";
                    v = 0.0425 + 0.015*Math.random();
                    break;
            case 1:
            case 2:
                    w = h = 25;
                    color = "red";
                    v = 0.085 + 0.03*Math.random();
                    break;
            case 3:
            case 4:
            case 5:
                    w = h = 15;
                    color = "green";
                    v = 0.17 + 0.06*Math.random();
        }
        x = W;
        y = HeaderH + (H-HeaderH-h)*Math.random();
        angle = Objects.getCurrentAngle();
		
        if (isSquare) Objects.add( new bRect(x, y, w, h, color, v, angle) );
        if (isCircle) Objects.add( new bCircle(x+w/2, y+w/2, w/2, color, v, angle) );
    }
	
    this.spawnSquare = function(num){
        for (var i=0; i<num; i++)
            spawnSquareOrCircle(true, false);
        Game.spawned(num);
    }
    this.spawnCircle = function(num){
        for (var i=0; i<num; i++)
            spawnSquareOrCircle(false, true);
        Game.spawned(num);
    }
    this.spawnRandom = function(num){
        for (var i=0; i<num; i++){
            var flag = Math.floor(Math.random() * 2); // = 0 or 1
            spawnSquareOrCircle(flag, !flag);
        }
        Game.spawned(num);
    }
}

// RECT CLASS
function bRect(x, y, w, h, color, v, angle){
    var x = x, y = y,       // coords
        w = w, h = h,       // width, height
        color = color,
        v = v,              // speed
        angle = angle,      // moving angle
        // x, y direction speed
        vx = v * Math.cos( angle ),
        vy = v * Math.sin( angle );
    this.collided = false;  // collision with player, so it counts only once
	
    this.getSides = function(){ return {left: x, top: y, right: x+w, bottom: y+h} }
    this.getColor = function(){ return color }
	
    this.move = function(diff, mainAngle){
        // adjust speed if angle changed
        var turningDuration = 2000; // ms
        if ( angle !== mainAngle ){
            angle += mainAngle>angle ?
            ( (Math.PI/4)/turningDuration ) * diff :
            ( -(Math.PI/4)/turningDuration ) * diff ;
            vx = v * Math.cos( angle );
            vy = v * Math.sin( angle );
        }
        
        x += vx * diff;
        y += vy * diff;
		
        var out = false;
        if (x<-w && vx<0) out = true;
        
        if (y+h < HeaderH || y > H){
            y = vy<0 ? H : HeaderH-h;
        }
		
        return out;
    }
    this.draw = function(){
        var temp = Drawing.fillStyle;
        
        Drawing.fillStyle = color;
        Drawing.fillRect(x, y, w, h);
        
        Drawing.fillStyle = temp;
    }
}

// CIRCLE CLASS
function bCircle(x, y, r, color, v, angle){
    var x = x, y = y,       // coords
        r = r,              // radius
        color = color,
        v = v,              // speed
        angle = angle,      // moving angle
        // x, y direction speed
        vx = v * Math.cos( angle ),
        vy = v * Math.sin( angle );
    this.collided = false;  // collision with player, so it counts only once
	
    this.getSides = function(){
        // approximating circle as square, side = 0.8 * 2*r
        var approx = 0.8;
        return {left: x-r*approx, top: y-r*approx, right: x+r*approx, bottom: y+r*approx};
    }
    this.getColor = function(){ return color }
	
    this.move = function(diff, mainAngle){
         // adjust speed if angle changed
        if ( angle !== mainAngle ){
            angle = mainAngle;
            vx = v * Math.cos( angle );
            vy = v * Math.sin( angle );
        }
        
        x += vx * diff;
        y += vy * diff;

        var out = false;
        if (x<-r && vx<0) out = true;
        
        if (y+r < HeaderH || y-r > H){
            y = vy<0 ? H+r : HeaderH-r;
        }
		
        return out;
    }
    this.draw = function(){
        var temp = Drawing.fillStyle;
        
        Drawing.fillStyle = color;
        Drawing.beginPath();
        Drawing.arc(x, y, r, 0, Math.PI*2, true);
        Drawing.closePath();
        Drawing.fill();
        
        Drawing.fillStyle = temp;
    }
}

//PLAYER CLASS
function player(){
    var w = 32, h = 16,             // width, height
        // coords set to middle of screen
        x = W/5 - w/2,
        y = Math.floor( HeaderH + (H-HeaderH)/2 - h/2 ),
        
        color = "gray",
        v = 0.125,                  // speed     
        xModifier = 2, yFlag = 0;   // used for flame drawing
    this.isHit = false;
	
    this.getSides = function(){ return {left: x, top: y, right: x+w, bottom: y+h} }
	
    this.move = function(diff){
        xModifier = 2;
        yFlag = 0;
        // diplacements
        var dx = 0,
            dy = 0;
        
        if (Keys[UP] && !Keys[DOWN]){
            dy = -v * diff;
            yFlag = 1;
            if (y-h/8 < HeaderH+1) y = HeaderH+1 + h/8;
        }
        if (Keys[DOWN] && !Keys[UP]){
            dy = v * diff;
            yFlag = -1;
            if (y+h+h/8 > H-1) y = H-1 - h - h/8;
        }
        if (Keys[LEFT] && !Keys[RIGHT]){
            dx = -v * diff;
            xModifier = 1;
            if (x < 0) x = 0;
        }
        if (Keys[RIGHT] && !Keys[LEFT]){
            dx = v * diff;
            xModifier = 4;
            if (x+w+w/8 > W) x = W - w - w/8;
        }
        
        if ( dx&&dy ){
            dx *= Math.cos( Math.PI/4 );
            dy *= Math.sin( Math.PI/4 );
        }
        
        x += dx;
        y += dy;
    }
    this.draw = function(){
        var temp = Drawing.fillStyle;
        
        if (this.isHit){
            Drawing.fillStyle = "white";
            Drawing.strokeStyle = "black";
        }
        else{
            Drawing.fillStyle = "orange";
            Drawing.strokeStyle = "brown";
        }
        
        /* xModifier: 1 - moving back
         *            2 - standing
         *            4 - moving forward
         * yFlag:     0 - standing
         *            1 - moving up
         *            2 - moving down */
        
        // back fire
        Drawing.beginPath();
        Drawing.moveTo(x, y + h/8);
        Drawing.lineTo(x - xModifier*h/4, y + h/2);
        Drawing.lineTo(x, y + 7*h/8);
        Drawing.closePath();
        Drawing.fill();
        Drawing.stroke();
        
        // side fire
        switch (yFlag){
            case 0: break;
            case 1:
                    Drawing.beginPath();
                    Drawing.moveTo(x + 2*w/8, y + h);
                    Drawing.lineTo(x + 3*w/8, y + h + 3*h/8);
                    Drawing.lineTo(x + 4*w/8 , y + h);
                    Drawing.closePath();
                    Drawing.fill();
                    Drawing.stroke();
                    break;
            case -1:
                    Drawing.beginPath();
                    Drawing.moveTo(x + 2*w/8, y);
                    Drawing.lineTo(x + 3*w/8, y - 3*h/8);
                    Drawing.lineTo(x + 4*w/8, y);
                    Drawing.closePath();
                    Drawing.fill();
                    Drawing.stroke();
        }
        
        // body
        if (this.isHit) Drawing.fillStyle = "#FFCC00";
        else Drawing.fillStyle = color;
        Drawing.beginPath();
        Drawing.moveTo(x, y - h/8);
        Drawing.lineTo(x + w - w/8, y);
        Drawing.lineTo(x + w + w/8, y + h/2);
        Drawing.lineTo(x + w - w/8, y + h);
        Drawing.lineTo(x, y + h + h/8);
        Drawing.closePath();
        Drawing.fill();
        
        Drawing.fillStyle = temp;
    }
}

// OBJECT MANAGER CLASS
function objectManager(){
    var Player = new player(),
        // enemies sorted by type/color
        all = { blue: [], red: [], green: [] },
        // movement angle for all objects
        angle = Math.PI,    // jumps
        realAngle = angle,  // changes gradually
        /* state for the turning rotation 
         * 0: normal angle, previously down
         * 1: upwards angle
         * 2: normal angle, previously up
         * 3: downwards angle */
        turningState = 0;
	
    var turn = function(){
        switch ( turningState ){
            case 0:
                angle = 3 * Math.PI/4;
                break;
            case 1:
                angle = Math.PI;
                break;
            case 2:
                angle = 5 * Math.PI/4;
                break;
            case 3:
                angle = Math.PI;
        }
        
        turningState = (turningState+1)%4;
    }
        
    this.getCurrentAngle = function(){ return realAngle; }
    this.add = function(obj){
        all[ obj.getColor() ].push(obj);
    }
    this.moveAll = function(diff){
        // turn all enemies if the time has come
        if ( Game.canTurn() ) turn();
        // adjust angle to new angle
        var turningDuration = 2000; // ms
        if ( realAngle !== angle ){
            realAngle += angle>realAngle ?
            ( (Math.PI/4)/turningDuration ) * diff :
            ( -(Math.PI/4)/turningDuration ) * diff ;
        }
        
        var num = 0; // for couting despawned enemies
        for (var i in all)
            for (var j in all[i])
                // remove enemy out of screen
                if ( all[i][j].move(diff, realAngle) ){
                    all[i].splice(j,1);
                    num++;
                }
        
        Player.move(diff);
        
        // respawn despawned enemies
        if (num){
            Game.despawned(num);
            Spawner.spawnRandom(num);
        }
    }
    this.drawAll = function(){
        // clipping - no drawing over header
        Drawing.save();
        Drawing.rect(0, HeaderH, W, H-HeaderH);
        Drawing.clip();
        
        for (var i in all.blue) all.blue[i].draw();
        for (var i in all.red) all.red[i].draw();
        for (var i in all.green) all.green[i].draw();
        Player.draw();
        
        Drawing.restore();
    }
    this.checkCollisions = function(){
        var sum = 0,    // for counting all new collisions
            playerHit = false,
            pSides = Player.getSides(),
            other;
    
        for (var i in all)
            for (var j in all[i]){
                other = all[i][j].getSides();
                //collsion condition
                if ( other.left<pSides.right &&
                     other.top<pSides.bottom &&
                     other.right>pSides.left &&
                     other.bottom>pSides.top ){
                 
                    if (!all[i][j].collided){
                        all[i][j].collided = true;
                        sum++;						
                    }
                    playerHit = true;
                }else if (all[i][j].collided) all[i][j].collided = false;
            }
        Player.isHit = playerHit;
        return sum;
    }
}

</script>
</body>
</html>